# 一、 数据结构

### 1、**常见运算**

```java
//取模运算:余数,可以用作循环
5%2 = 1
5/2 = 2
i++ //输出后再加
++i //加完再输出  
```



### 2、**数组、链表、跳表**

* 原始数组

  ```java
  //1、 数据类型 [] 数组名=new 数据类型[ length];
  int[] ary = new int[4];//初始化值为0
  //2、初始化
  int[] ary2 = {0, 1, 2};
  //数组扩容,拷贝
  int[] newInts = Arrays.copyOf(ary2, 5);//表面上对数组长度进行扩容，实际新开辟一个空间
  System.out.println(Arrays.toString(newInts));//[0, 1, 0, 0, 0]
  //数组复制
  System.arraycopy(ary2, 1, ary, 1, 2);//把ary2中的内容从下标1开始复制到ary中，复制长度2
  System.out.println(Arrays.toString(ary));//[0, 1, 2, 0]
  ```

* ArrayList

  ```java
  public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;//学习写法：添加到size位置后，size++
    return true;
  }
  ```

* 链表

  ```java
  //双向链表
  class Node {
      public int key, val;
      public Node next, prev;
      public Node(int k, int v) {
          this.key = k;
          this.val = v;
      }
  }
  ```

  

* 跳表

  * 升维：增加多级索引Olog(n)；随着增加删除索引索引可能需要重建，空间复杂度O(n)

####解题模板

* 遍历

  ```java
  /* 基本的单链表节点 */
  class ListNode {
      int val;
      ListNode next;
  }
  
  void traverse(ListNode head) {
      for (ListNode p = head; p != null; p = p.next) {
          // 迭代访问 p.val
      }
  }
  
  void traverse(ListNode head) {
      // 递归访问 head.val
      traverse(head.next);
  }
  ```

  



#### 力扣刷题

#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

* **题解**：LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：

<img src="https://pic.leetcode-cn.com/b84cf65debb43b28bd212787ca63d34c9962696ed427f638763be71a3cb8f89d.jpg" alt="HashLinkedList" style="zoom:50%;" />



* **答案**

  ```java
  class LRUCache { 
      private HashMap<Integer, Node> map;
      private DoubleList cache;
      // 最大容量
      private int cap;
  
      public LRUCache(int capacity) {
          this.cap = capacity;
          map = new HashMap<>();
          cache = new DoubleList();
      }
  
      public int get(int key) {
          if (!map.containsKey(key)) return -1;
          int val = map.get(key).val;
          // 利用 put 方法把该数据提前
          put(key, val);
          return val;
      }
  
      public void put(int key, int val) {
          // 先把新节点 x 做出来
          Node x = new Node(key, val);
          if (map.containsKey(key)) {
              // 删除旧的节点，新的插到头部
              cache.remove(map.get(key));
              cache.addFirst(x);
              // 更新 map 中对应的数据
              map.put(key, x);
          } else {
            	//满了则删除链表最后一个数据
              if (cap == cache.size()) {
                  Node last = cache.removeLast();
                  map.remove(last.key);
              }
              // 直接添加到头部
              cache.addFirst(x);
              map.put(key, x);
          }
      }
  
      static class DoubleList {
        	//确保链表不为空，头结点为first.next
          private Node first = new Node(0, 0);
          private Node end = new Node(0, 0);
          private int size;
  
          public DoubleList() {
              first.next = end;
              end.prev = first;
              size = 0;
          }
  
          // 在链表头部添加节点 x，时间 O(1)
          public void addFirst(Node x) {
              Node temp = first.next;
              first.next = x;//第二个才是插入的头结点
              x.next = temp;
              temp.prev = x;
              x.prev = first;
              size++;
          }
          // 删除链表中的 x 节点（x 一定存在）
          // 由于是双链表且给的是目标 Node 节点，时间 O(1)
          public void remove(Node x) {
              x.next.prev = x.prev;
              x.prev.next = x.next;
              size--;
          }
          // 删除链表中最后一个节点，并返回该节点，时间 O(1)
          public Node removeLast() {
              Node last = end.prev;
              remove(last);
              return last;
          }
  
          // 返回链表长度，时间 O(1)
          public int size() {
              return size;
          }
      }
  
      static class Node {
          public int key, val;
          public Node next, prev;
  
          public Node(int k, int v) {
              this.key = k;
              this.val = v;
          }
      }
  }
  ```

  作者：labuladong
  链接：https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/

  

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

*给定一个链表*，返回链表开始**入环的第一个节点**。 如果链表无环，则返回 `null`

* 解题思路
  - 这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。
  - slow再走a = 入口 = head走到入口 = a

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        //快慢指针
        //每次移动两步,有环则一定会在环的 某一个位置 超越慢指针
        ListNode fast = head, slow = head;
        while(true){
            if(fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) break;
        }
        // 假如fast == head --> 有环
        fast = head;
        while(fast != slow){
           fast = fast.next; 
           slow = slow.next;
        }
        return fast;
    }
}
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

* **解题思路**

  定义两个指针： pre（前） 和 cur(后) ；每次让 cur 的 next 指向 per ，实现一次局部反转，局部反转完成之后，pre 和 cur 同时往前移动一个位置，循环上述过程，直至 pre到达链表尾部

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        //双指针实现
        ListNode per = null;
        ListNode cur = head;
        ListNode temp = null;
        while(cur != null){
            temp = cur.next;
            //改变指向，局部反转
            cur.next = per;
            //指针向前移动
            per = cur;
            cur = temp;
        }
        return per;
    }
}
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

*给定一个链表，判断链表中是否有环*

* **解题思路**

  1、快慢指针，有环则一定追上；

  2、Set集合或者数组：存在则一定有环

```java
public boolean hasCycle(ListNode head) {
  //快慢指针
  ListNode f = head, s = head;
  while(true){
    if(f == null || f.next == null) return false;
    f = f.next.next;
    s = s.next;
    if(f == s) return true;
  }
}
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

*将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。*

*  **解题思路**
  * 迭代法：因为有序可以一次遍历两个链表，通过比较，改变指向，其中一个遍历完毕，把另一个指向最后即可

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //迭代法
        ListNode head = new ListNode(-1);
        //维护一个指针
        ListNode per = head;
        while(l1 != null && l2 != null){
            if(l1.val >= l2.val){
                per.next = l2;
                l2 = l2.next;
            }else{
                per.next = l1;
                l1 = l1.next;
            }
            //指针后移一位
            per = per.next;
        }
        //链表末尾指向不为空的链表
        per.next = l1 == null ? l2 : l1;
        return head.next;
}
```

* 递归解法

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //递归解法
        if(l1 == null) return l2;
        if(l2 == null) return l1;

        if(l1.val > l2.val){
           l2.next = mergeTwoLists(l1, l2.next);
           return l2;
        }else{
           l1.next =  mergeTwoLists(l1.next, l2);
           return l1;
        }
}
```

